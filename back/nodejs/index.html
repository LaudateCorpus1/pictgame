<!doctype html>
<html>

<head>
  <title>Socket.IO chat</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font: 13px Helvetica, Arial;
      background-color: #000;
    }

    form {
      background: #000;
      padding: 3px;
      position: fixed;
      bottom: 0;
      width: 100%;
    }

    form input {
      border: 0;
      padding: 10px;
      width: 90%;
      margin-right: 0.5%;
    }

    form button {
      width: 9%;
      background: rgb(130, 224, 255);
      border: none;
      padding: 10px;
    }

    #messages {
      list-style-type: none;
      margin: 0;
      padding: 0;
    }

    #messages li {
      padding: 5px 10px;
    }

    #messages li:nth-child(odd) {
      background: #eee;
    }
  </style>
</head>

<body>
  <ul id="messages"></ul>
  <form action="">
    <input id="m" autocomplete="off" /><button>Send</button>
  </form>
  <script src="/socket.io/socket.io.js"></script>
  <script async>
    const socket = io();
    let data = null;

    const msgType = Object.freeze({ "HELLO": 'HELLO', "DATA": 'DATA' });

    const hlo = () => { socket.emit(msgType.HELLO, {}) };
    const sd = (data) => { socket.emit(msgType.DATA, tgt, data); };

    socket.on(msgType.HELLO, console.log);
    socket.on(msgType.DATA, (d) => { data = d });

    const ecdhDevParams = { name: "ECDH", namedCurve: "P-256" };
    const aesParams = { name: "AES-GCM", length: 256 };

    // derive my key pair
    let keyPair, myPub, sharedKey;

    window.crypto.subtle.generateKey(
      ecdhDevParams,
      false,
      ["deriveKey", "deriveBits"]
    ).then(key => {
      keyPair = key;
      return window.crypto.subtle.exportKey("raw", keyPair.publicKey);
    }).then(k => { myPub = _arrayBufferToBase64(k); console.log("keys ready"); });

    // receive bob's pub key in base64 format
    impkey = async (bobPub) => {
      const bobPubKey = await window.crypto.subtle.importKey(
        "raw",
        _base64ToArrayBuffer(bobPub),
        ecdhDevParams,
        true,
        []
      );

      // generate shared key
      sharedKey = await window.crypto.subtle.deriveKey(
        { name: ecdhDevParams.name, public: bobPubKey },
        keyPair.privateKey,
        aesParams,
        false,
        ["encrypt", "decrypt"]
      );
    };

    // TODO: how the data is encoded into bytes should be decided by caller
    // as calling JSON.stringify on Buffers is wasteful
    enc = async (data) => {
      // generate iv and encrypt response
      const iv = window.crypto.getRandomValues(new Uint8Array(96));
      const encres = await window.crypto.subtle.encrypt(
        { ...aesParams, iv },
        sharedKey,
        new TextEncoder().encode(JSON.stringify(data))
      );
      return [_arrayBufferToBase64(iv), _arrayBufferToBase64(encres)];
    }

    // recv data from bob
    dec = async (data) => {
      iv = _base64ToArrayBuffer(data[1][0])
      encres = _base64ToArrayBuffer(data[1][1])
      const decres = await window.crypto.subtle.decrypt(
        { ...aesParams, iv },
        sharedKey,
        encres
      );
      return JSON.parse(new TextDecoder().decode(decres));
    }

    function _arrayBufferToBase64(buffer) {
      var binary = '';
      var bytes = new Uint8Array(buffer);
      var len = bytes.byteLength;
      for (var i = 0; i < len; i++) {
        binary += String.fromCharCode(bytes[i]);
      }
      return window.btoa(binary);
    }

    function _base64ToArrayBuffer(base64) {
      var binary_string = window.atob(base64);
      var len = binary_string.length;
      var bytes = new Uint8Array(len);
      for (var i = 0; i < len; i++) {
        bytes[i] = binary_string.charCodeAt(i);
      }
      return bytes.buffer;
    }

    hlo();

  </script>
</body>

</html>